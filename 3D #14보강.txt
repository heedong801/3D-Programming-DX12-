4/30
명령 리스트의 실행

void ID3D12CommandQueue::ExecuteCo...
이 함수는 명령어 개수와 그 개수만큼의 배열을 받고 집어넣는 함수

Close()
커맨드 리스트들은 항상 닫힌 상태여야만 집어넣을 수 있음

아래 예를 통해 Reset하면 커맨드 리스트는 비워지고
그 아래 함수들로 RSSetView 등에 명령어등이 리스트에 들어감
(이 때 실행되는 것이 아님) -> 실행은 GPU가 꺼내갔을때 실행
(차례대로 돌고 때가 되어야 실행됨)
마지막에 Set 했으니 Draw 하고 집어넣기 위해서 Close로 닫고
Execute로 커맨드큐로 집어넣음

이 후 GPU가 커맨드큐에서 명령어를 차례차례 실행시킴

각각의 커맨드들은 그리기 위한 데이터(메쉬, 월드변환행렬, 카메라 정보, 조명, 텍스처 정보 등)가 필요하다 -> 리소스에서 제공, 이 데이터들은 비디오메모리에 있어야한다. 리소스 = 비디오메모리에 있는 렌더링데이터,
이 리소스는(CreateCommittedResource, CreatePlacedResource, CreateReservedResource) 등으로 만듬

1번과정 리소스 만들고, 3번과정 리소스를 꺼내다가 씀
CPU는 리소스를 바꿔가는 역할, GPU는 리소스를 꺼내쓰는 역할

2개의 CPU가 한 리소스를 같이 쓰려하면 동기화가 필요
동기화란 쉽게 말해 줄서기.

1->2->3->4 = CPU가 데이터를 리소스에 쓰고 커맨드 리스트에 등록하면 리소스를 불러서 실행하고 다음 프레임에서 리소스를 다시 쓰는 순서

CPU가 커맨드리스트들을 모두 실행했을 때 다음 프레임으로 넘어가는 걸 지원해주는 Fence인터페이스로 CPU와 GPU동기화할때 사용.

내부적으로 64비트짜리 데이터를 가지고 있음.

공유펜스는 - 멀티스레드때 사용
GPU공유는 - GPU가 여러개인 상황에서 GPU끼리 공유되는 상황에서 사용
동기화 오브젝트가 필요

모든 HANDLE은 UINT로 윈도우에는 많은 테이블이 있는데, HANDLE은 이 테이블에 인덱스를 의미, 테이블의 값은 실제 메모리에 주소, 이벤트들을 관리하는 테이블 역시 존재하는데, 그 테이블의 인덱스를 HANDEL이라고 하고 hEvent라고 보면 됨 왜 반환값이 HANDLE이라면 이 놈은 따로 테이블이 있는게 아니라 엄청 큰 테이블안에 소속되어 있는 놈에 인덱스를 반환해서 그냥 HANDLE이다

hEvent값이 Value에 도달하면 실행된다.

GetCompleted 원하는 값이 < m_nFenceValue보다 작으면 참이되서
안에 hFenceEvent가 m_nFenceValue값이 될때 실행해
WaitForSingle은 기다려 무한정으로 저 함수가 수행될때 까지

이 방법으로 CPU와 GPU가 동기화한다.