5/3
ID3D12DescriptorHeap
디스크립터를 생성 전 디스크립터들을 저장할 수 있는 배열 생성
CPU에서 사용하기 위한 디스크립터힙 주소와 GPU에서 사용하기 위한 디스크립터힙 따로 사용

Create로시작하고 view로 끝나는 함수들은 마지막 파라미터가 디스크립터힙을 의미

래스터라이저단계 설정
뒤에서 나올거니까 일단 생략

응용프로그램워크
Bulid에서 대부분 Create함수 사용하고 렌더에 사용할 경우 프레임저하를 일으키므로 가급적 사용 x

Pipeline01
Direct3D 9 파이프라인 : 그냥 넘어감
Direct3D 12 파이프라인 : 중요(출력)
쉐이더 : GPU에서 사용되는 함수 or 프로그램

고정프로그램 단계는 함수가 미리 정의되어 있어 사용자는 인자값만 달리 할 수 있다.
반대로 프로그램 가능 단계는 어떤 것도 정의되어 있지 않아 다 정해줄 수 있다.

점선의 해당되는 단계는 테셀레이션 단계

프로그램 가능 단계에 함수를 지정하지 않으면 작동하지 않음

입력-조립 단계
시멘틱 : 어떤 변수에 부착이 되어있는 문자열
SV = System-Generated Values

인스턴스 = 오브젝트

래스터라이저 단계
보간 : 정점 데이터 말고 픽셀의 데이터를 계산하는 과정

출력병합 단계
깊이 스텐실 검사
블렌딩 : 두 개이상의 색깔을 섞는것

Direct3d 파이프라인
상수 바퍼 : 특별한 버펴 중요한건

템플러가 상수 버퍼 같으놈들 다룰수 잇음

항상 그리기전에 쉐이더 함수 바꾸어줘야함 (ex Set함)

=======================================================================================================

디스크립터 힙 생성 -> 디스크립터 생성 -> 디스크립터 힙 원소 크기 파악
디스크립터를 만들려면 ( Create로 시작 View로 끝나는 함수로 서술자(뷰)를 만들 수 있음 )

RSSetViewports : 뷰포트를 set하는 함수

DXGI 후면버퍼 생성 -> 가져다가 렌더타겟 생성 

윈도우 생성 -> 메세지 루프 변경 - > 게임프레임 워크 객체 생성 -> 프레임어드밴스 -> 디바이스 초기화가 먼저... (모델을 불러오는 일, Device의 Create함수 등)OnCreate함수
입력값에 따라서 객체들의 움직임 -> animate
#pragma라는 전처리 지시문으로 임포트 라이브러리를 컴파일러가 자동으로 링크하도록 해줌(따로 링커할 필요x)

쉐이더 : GPU에서 실행되는 프로그램 ( 함수 )

VS : 정점에 관한 일(변환의 4단계를 여기서 해주면 될듯?)
PS : 픽셀에 관해 색깔
쉐이더 단계가 없으면 그 사이에 있는 단계들은 전혀 실행되지 않음

입력 조립단계
버텍스버퍼에 있는 정점들을 파이프라인 나머지단계에서 사용하기 위한 프리미티브로 조립하는 단계

시멘틱 : 변수에 붙는 문자열 왜 붙이냐 ? 그 변수의 이름이 어떤 용도인지 설명을 해주진 않음
ex) 나이에 대해서 int b but int b : age 라고 해놓으면 소스코드를 볼 때 가독성이 좋아짐 
시멘틱들 중에 이걸로 시작하는 문자열은 SV( System-Generated Valuse)로 어떤 변수에 이게 붙어있으면
그 변수는 파이프라인 or GPU에서 생성한 값을 가지고 있는 변수로 그 의미가 GPU에서 정해놓은 것들

GPU에서 제공하는 인스터싱 ( 같은 메쉬를 공유하는 100개의 객체의 경우 )
삼각형 두개를 만들었을 경우, 첫번째 삼각형을 파이프라인에 흘려보낼 때 첫번째인 것을 알려주기 위해 int형 변수 하나 만들어서 거기다가 인스터스 ID를 넣고 꼬리표에다가 인스터스ID라는 시멘틱을 붙여서 흘려보내면 파이프라인에서는 현재 몇번째 객체를 그리는 지 구별가능.

래스터라이즈( 가장 중요한 일 중 하나 픽셀을 찾아내고, 그 찾아낸 픽셀의 정점 데이터를 사용하여 내부에 있는 모든 픽셀들이 정점하고 똑같은 정보를 가지도록 보간을 해서 그 데이터를 PS에 넘기는 것 )
벡터 정보(프리미티브)를 래스터이미지(픽셀)로 변환하는 단계
프리미티브를 구성하는 픽셀들을 찾아내는 단계
이 픽셀이 가지고 있는 정보는 이 정점의 정보를 복사했으니 똑같음
꼭지점에 해당하는 놈들은 정점의 정보들을 가지고 있음
But 그러나 꼭지점이 아닌 삼각형 안에 있는 픽셀들은 보간을 통해서 구해야함
래스터라이즈는 보간방법을 정해주지 않을 경우 기본적으로 선형보간을 사용

픽셀 쉐이더
RS가 넘겨주는 픽셀의 정보를 사용해서 찾아낸 모든 픽셀들에 대해서 색깔을 결정해줘야 함

출력 병합 단계(뎁스 테스트, 스텐실 검사)
현재 픽셀의 색상이 렌더타겟에 출력이 되는지 결정 할 수 있다.
블랜딩(두 개이상의 색을 섞는 것)을 하면 투명한 것을 그릴 수 있다.
이 두가지 과정을 통해서 최종적으로 렌더타겟의 픽셀을 출력하는 일을 한다.

세이더함수( 공통 )
함수로 이전 단계의 출력을 입력으로 받는다
함수가 동작하기 위한 리소스가 필요한 데, 그 리소스는 버퍼, 텍스쳐 이다. -쉐이더 리소스라고 부름
상수버퍼는 버퍼 중에 특별한 의미를 가진 버퍼
텍스처는 항상 샘플러가 있어야만 읽을 수 있음
쉐이더함수를 바꾸면 그리는 방법이 달라짐(Set)

정점 쉐이더
프리미티브를 구성하고 있는 정점의 개수만큼 정점 쉐이더 호출
나온 정점으로 연산은 여기서 하면 됨(ex 변환)
모핑 - 프리미티브의 모양을 바꿀 수 있음
스키닝 - 뼈대에 따라서 정점의 위치 바꿔 주는거