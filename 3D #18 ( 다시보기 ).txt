5/8(Pipeline01)
Direct3D 쉐이더 단계

정점-쉐이더 단계
대부분 Transformation계산 수행 T&L 중에 T단계 모델 -> 월드
하나의 정점에 대하여 한 번 호출, 하나의 출력 정점을 생성
그래픽스 파이프라인에서 반드시 실행이 되어야 하는 단계
입력으로 16개까지의 벡터 입력 가능 -> 64개의 실수 입력 가능 -> 4개의 행렬
출력으로 16개까지의 벡터 출력 가능
입력과  출력으로 저 리미트만 지켜주면 어떻게든 사용가능( 예를 들어 어떤 함수의 매개변수 실수 하나 입력받아서 단위 행렬 리턴가능)

입력 조립 단계에서 SV_primitiveID도 같이 흘려 보내줌 총 3개

픽셀에 대하여 픽셀-쉐이더를 한번씩 호출

오브젝트를 그릴려면?
-모델
-행렬

픽셀 쉐이더 - 픽셀에 대해 연산을 해서 픽셀의 색깔을 결정해주는 단계 T&L 중에 L단계(텍스퍼매핑 or 조명계산도 포함)
	    - 기하쉐이더의 유무에 따라서 입력으로 32개의 벡터를 사용할 수 있고, 출력으로 출력병합단계에 색깔(8개의 벡터) 리턴
	    - 렌더타겟마다 하나의 색 이어줘야함, 각각의 색상은 각각의 렌더타겟으로 들어감

버텍스 라이팅의 의미 - 정점들의 조명계산을 한 후 래스터화 과정에선 픽셀의 대한 정보로 보간함, 프레임이 차이가 많이 안날거임
픽셀 라이팅으로 조명 계산을 하면? - 모든 픽셀에 대해 조명 계산, 멀면 조금 가까우면 많이 호출해서 프레임 차이 심함

시멘틱
각 단계의 출력들이 다음 단계의 입력이 될 때 시멘틱으로 구분해준다.
SV로 시작되는 시멘틱들은 정해진 용도대로만 쓰여져함

버텍스쉐이더(입력조집 작업)

트랜스폼이 되었다->투영자표계로 표현됐다
sv_Target = 렌더타겟

sv타겟은 픽셀세이더에서 필수 생성해야함

정점 쉐이더 단계 준비 -> Set

바이트코드란?

D3DCompileFrimFile함수
2번째 인자는 디파인으로 대체가능
3번째 인자 저거 넣어야 인클루드 가능

Flag1을 Debug or Optimi 같이 하는 게 일반적 디버그하랴먄 ㅇㅇ

=======================================================================================================
메모리 리소스 중 텍스처는 샘플러를 통해 사용이 된다.

정점-셰이더 단계
One Input One Output
프리미티브의 각 정점에 대한 연산을 수행(변환, 스키닝, 모핑, 조명)

SV_VertexID : 현재 몇번째 정점을 나타내는 지 
SV_InstanceID : 몇번째 객체를 그리고 있는지
SV_PrimitiveID : 몇번째 프리미티브 인지

정점-셰이더에는 정점데이터,상수버퍼,텍스처,버퍼 이것이 리소스로 입력으로 파라미터로 넘겨받음

픽셀-셰이더 단계
레스터가 찾은 픽셀을 넘겨받음 ( 픽셀셰이더 함수의 파라미터로 )
하나의 프리미티브를 구성하는 각 픽셀에 대해서 한번씩 호출
픽셀의 색깔을 결정해주는 단계

조명계산은 비용이 크다
각 정점에 대해서 조명계산을 한다면 (버텍스 셰이더에서 조명계산을 하면) 정점의 색깔이 정해지면 -> 래스터라이저는 정점에 대한 데이터로 픽셀들의 데이터를 보간으로 구할 수 있음, 삼각형의 경우 3번 호출
그러면 이 삼각형이 카메라에 가까이 있던 멀리 있던 딱 세번만 일어남

픽셀에 대해서 한다면 거리에 따라 조명계산횟수가 차이가 많음

출력병합에서 렌더타겟을 최대 8개 연결가능하므로 픽셀 셰이더는 렌더타겟의 들어가야 하는 색깔을 하나씩 리턴이 가능 그래서 최대 8개로, 렌더타겟마다 하나씩 리턴해야함. 1개 이어져있으면 1개만 리턴

시멘틱
셰이더의 입력과 출력을 연결하기 위한 문자열
파라미터의 순서가 아닌 시멘틱으로 구별이 됨

SV_Position : Transform이 된 위치벡터(투영좌표계로 표현된 거 )( 버텍스 셰이더에 무조건 있어야 중간과정이 없었을 때 래스터 라이즈가 원근투영 나누기를 할 수 있음 )
SV_Target : 출력병합에 렌더타겟이 몇개 이어졌냐에 따라 픽셀 셰이더에 출력에는 이 시멘틱이 붙어 있어야 함
래스터라이즈 : 원근투영 나누기 ( 그전에 원근투영변환행렬을 곱한 후가 되어야함 ) - 클리핑 - 뷰포트로 픽셀좌표를 찾음 - 각 픽셀에 대해서 픽셀 좌표 찾음

그래픽 파이프라인 상태
모든 코드는 컴파일하면 오브젝트 코드가 생김
HLSL로 만든 셰이더 코드들도 컴파일하고 컴파일한 코드들을 GPU에게 연결을 해야한다.
그 함수 D3DCompileFromFile() 그러면 바이트 코드 생성
리턴값에 따라 오륜지 아니지 오류면 어떤 오륜지 파악가능
블롭이라 하는 인터페이스는 그냥 컴파일된 메모리 덩어리(겟버퍼포인터, 겟버퍼사이즈 라는 함수 가지고있)
겟버퍼 포인터 - 시작주소 리턴, 겟버퍼사이즈 - 바이트크기 리턴

바이트코드란?
자바랭귀지로 만든 표준화 되어있는 코드로 CPU가 달라질 때마다 그 CPU에 맞게 번역
GPU에서 실행될 수 있는 표준적인 바이트 코드로 바꾸고 GPU에 맞게 번역

===================================================================================================
 