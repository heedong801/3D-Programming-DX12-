5/15 pipeline01 
쉐이더 컴파일

진입점 이름에 실제 쉐이더 함수 기입
쉐이더 형식 역시 변경 가능
이 2가지만 적용해줘도 .cso(쉐이더파일 컴파일)

vs에서 쉐이더코드 컴파일시 생기는 이점
-만약 소스코드에 오류가 생기면 바이너리 코드 미생성 -> 그래픽스 파이프라인 생성 불가
vs에서 미리 컴파일 하면 어디서 무슨 에러가 났는지 확인해서 오류 수정 가능
-미리 컴파일해서, 프로그램 실행시 컴파일 시간 감소 ( 실행이 빨라짐 )

컴파일된 쉐이더 코드 읽기
파일을 읽어들여서 쉐이더를 만들 수 있는 형태

pipeline02
쉐이더 리소스 : 쉐이더가 사용하는 리소스
리소스 : (렌더링에 사용되는 데이터) 비디오 메모리의 존재

쉐이더 리소스 
입력 조립기에 정점 버퍼 뷰, 인덱스 버퍼등 연결
뷰(디스크립터) : 리소를 설명하기 위한 것
버퍼 : 상수버퍼 or 아닌버퍼 

CPU는 메인메모리를 쓰거나 읽는 경우 가 매우 빠름
GPU가 CPU보다 10배정도 빠름

cpU보다 GPU가 비디오메목 R/W 가 느림

매 프레임에서 비디오메모리에서 cpu로 읽는 과정이 있으면 프레임 급저하

Set : CPU에서 비디오메모리로 정보를 넘김 ( 느림 )
->Set을 적게하는 방법 ? Batch

목적 : 상태변화를 적게 하는 프로그래밍

힙 프로퍼티 : 확인?

입력 - 조립 단계 준비하기
서술자  : 리소스가 파이프라인에 연결이 될 때 직접 연결이 되지 않고 서술자를 연결하고, 서술자를 통하여 리소스를 확인 가능

INPUT ELEMENT DESC = 정점의 크기를 알려줌( 그래야 다음 정점을 가리킬 수 있음 )

layout ?

버텍스버퍼는 디폴트힙에다가 만듬

CPU가 가진 데이터를 디폴트 힙에 옮기려면
CPU에서 디폴트힙에 접근을 못하기 때문에 업로드 힙을 통해서 복사한다. gpu는 업로드 힙과 비디오메모리 영역 둘다 자유롭게 접근가능
업로드힙은 쓰고난 후 릴리즈 해준다.

모든 리소스에 대한 인터페이스 클래스는 리소스 인터페이스이다.

리소스의 갱신

Map함수는 리소스의 실제 포인터를 리턴해주는 함수, Map함수는 응용프로그램에서 호출
디폴트힙에 접근이 불가능 하기때문에 포인터를 얻어올 수 없고(접근) 그래서 포인터는 널 반환

업로드 힙의 경우 write용도 이기 때문에 read가 안된다.

업로드 힙 : CPU가 자주 사용해야 하는 경우(ex 월드변환행렬), 디폴트 힙에 정보를 넘기기 위해서
디폴트 힙 : 한 번 쓰고 더 이상 안쓸경우

맵을 하면 (주소를 얻어오면) 사용하고 반납해야 하지만, 업로드 힙의 경우 CPU가 자주 접근하는 걸 GPU도 알기에 UnMap을 안해도 됨
REDABACK은 쓰고 UnMAp 꼭 호출

서브리소스 : 텍스처에서만 적용(나중에 배움)

버퍼의 경우 서브리소스가 없으므로 0, RANGE도 null

리소스의 갱신
CopyResource : Upload heap -> copy -> Default heap 하는 함수 복사하는 바이트와 되는 바이트는 같아야한다.
반환형 void로 성공했는지 실패인지 구별불가

읽는 함수는 readback 타입에서만 사용 가능

======================================================================================================
VS2015 이후 버전에는 셰이더 컴파일러가 포함되어 있음
내가 만든 셰이더 코드를 d3d 컴파일프롬파일 함수에서 직접 컴파일 하려면 속성 창에서 빌드에서 제외를 예로 설정 해주면 됨.
d3d함수에서 말고 vs에서 컴파일 되게 하려면 vs와 ps를 별도의 파일로 만들어 줘야함 꼭 그런건 아님
보통은 vs, ps 에서 다른 파일에다가 만들고 그 파일에 해당하는 컴파일러 설정을 일반 설정을 하면 진입점 이름을 (Entry point)를 나타냄.

로딩 시 모든 셰이더를 읽어오면 로딩시간이 길어지는 데, 미리 컴파일 하여 셰이더 코드를 읽는 것으로 하면 시간을 줄일 수 있다. ppt 마지막 장에 대한 이해가 필요하다

정점 버퍼/인덱스 버퍼등의 리소스는 뷰를 통해 입력 조립기의 연결( 정점 버퍼 뷰 등 )

뷰나 디스크립터는 리소스르 설명하기 위한 데이터

모든 셰이던 단계들에는 버퍼가 연결되는데, 2가지로 나뉜다. 상수버퍼와 상수버퍼가 아닌거로, 텍스처
텍스처를 사용하는 데 중간에 샘플러를 통한다.

Cpu는 메인메모리에 읽기나 쓰기가 빠름 
Gpu는 비디오메모리에 읽기나 쓰기가 빠름
Gpu가 비디오메모리를 읽거나 쓰는 속도 10배 정도 빠름 > Cpu가 메인메모리 읽기 쓰기 속도


Cpu가 비디오메모리를 읽는 경우는 엄청나게 느림
원근투영변환 행렬의 경우 처음에 정해놓으면 안바뀜 -> 그러니 Load에서 하면 됨
그러나 카메라 변환행렬은 매 프레임마다 다시 써야할 경우가 많음 -> 왜냐면 플레이어가 위치나 방향이 수시로 바뀌기 때문 -> 그래서 비디오메모리에 매 프레임마다 써야함

바뀌지 않는 정보(메쉬, 투영변환행렬)들에 대해서는 Load에서 미리 써놓고, 동적으로 바뀌는 정보들은 바뀔 때마다 넘겨주어야 함. Set은 복수의 과정으로 정보를 넘기는 과정
Set을 적게한다는 것이 Batch의 개념

비디오 메모리에 리소스를 만들기 위해서 힙 프로퍼티를 넣어야 하는데 기본적으로 힙 프로퍼티는 3가지 타입이 있고 디폴트, 업로드, 리드백이 있다.

커미티드리소스 - 가상메모리, 비디오메모리 2가지 공간의 할당을 받는다.

입력 조립단계 정점 데이터를 저장할 수 있는 비디오 메모리 할당하고 그 다음에 그 리소스를 사용해서 정점 버퍼 뷰를 만들면 됨, 뷰를 만들어서 IA단계에 연결하면 됨

프리미티브 토폴로지 함수로 들어온 정점을 어떤 형태로 프리미티브로 조립할 지를 알려주는 함수

인풋 레이아웃 함수로 정점의 구조가 어떻게 되는지 표현해줌( 인풋 앨리먼트 디스크립션 배열 )
인풋 레이아웃을 셋하기 위해서는 그래픽스 파이프라인 스테이트에 멤버로 들어감

정점 버퍼는 커미티드 리소스 함수에서 리소스 스테이트를 버텍스 콘스탄트 버퍼로 지정

모든 다이렉ㅌ 함수는 CPU가 호출
MAP CPU가 리소스의 시작주소를 포인터로 얻어오겠다는 의미

MAP에 첫번째인자 0 두번째 NULL(0,0) 기입 세번째는 데이터에 대한 포인터의 주소 넘기면 됨

두 파이프라인이 Read-only 리소스에 대한 값을 같이 접근해도 동기화가 필요없음
하지만 누군가가 write하려하면 동기화가 필요