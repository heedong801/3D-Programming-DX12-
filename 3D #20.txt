5/15 pipeline01 
쉐이더 컴파일

진입점 이름에 실제 쉐이더 함수 기입
쉐이더 형식 역시 변경 가능
이 2가지만 적용해줘도 .cso(쉐이더파일 컴파일)

vs에서 쉐이더코드 컴파일시 생기는 이점
-만약 소스코드에 오류가 생기면 바이너리 코드 미생성 -> 그래픽스 파이프라인 생성 불가
vs에서 미리 컴파일 하면 어디서 무슨 에러가 났는지 확인해서 오류 수정 가능
-미리 컴파일해서, 프로그램 실행시 컴파일 시간 감소 ( 실행이 빨라짐 )

컴파일된 쉐이더 코드 읽기
파일을 읽어들여서 쉐이더를 만들 수 있는 형태

pipeline02
쉐이더 리소스 : 쉐이더가 사용하는 리소스
리소스 : (렌더링에 사용되는 데이터) 비디오 메모리의 존재

쉐이더 리소스 
입력 조립기에 정점 버퍼 뷰, 인덱스 버퍼등 연결
뷰(디스크립터) : 리소를 설명하기 위한 것
버퍼 : 상수버퍼 or 아닌버퍼 

CPU는 메인메모리를 쓰거나 읽는 경우 가 매우 빠름
GPU가 CPU보다 10배정도 빠름

cpU보다 GPU가 비디오메목 R/W 가 느림

매 프레임에서 비디오메모리에서 cpu로 읽는 과정이 있으면 프레임 급저하

Set : CPU에서 비디오메모리로 정보를 넘김 ( 느림 )
->Set을 적게하는 방법 ? Batch

목적 : 상태변화를 적게 하는 프로그래밍

힙 프로퍼티 : 확인?

입력 - 조립 단계 준비하기
서술자  : 리소스가 파이프라인에 연결이 될 때 직접 연결이 되지 않고 서술자를 연결하고, 서술자를 통하여 리소스를 확인 가능

INPUT ELEMENT DESC = 정점의 크기를 알려줌( 그래야 다음 정점을 가리킬 수 있음 )

layout ?

버텍스버퍼는 디폴트힙에다가 만듬

CPU가 가진 데이터를 디폴트 힙에 옮기려면
CPU에서 디폴트힙에 접근을 못하기 때문에 업로드 힙을 통해서 복사한다. gpu는 업로드 힙과 비디오메모리 영역 둘다 자유롭게 접근가능
업로드힙은 쓰고난 후 릴리즈 해준다.

모든 리소스에 대한 인터페이스 클래스는 리소스 인터페이스이다.

리소스의 갱신

Map함수는 리소스의 실제 포인터를 리턴해주는 함수, Map함수는 응용프로그램에서 호출
디폴트힙에 접근이 불가능 하기때문에 포인터를 얻어올 수 없고(접근) 그래서 포인터는 널 반환

업로드 힙의 경우 write용도 이기 때문에 read가 안된다.

업로드 힙 : CPU가 자주 사용해야 하는 경우(ex 월드변환행렬), 디폴트 힙에 정보를 넘기기 위해서
디폴트 힙 : 한 번 쓰고 더 이상 안쓸경우

맵을 하면 (주소를 얻어오면) 사용하고 반납해야 하지만, 업로드 힙의 경우 CPU가 자주 접근하는 걸 GPU도 알기에 UnMap을 안해도 됨
REDABACK은 쓰고 UnMAp 꼭 호출

서브리소스 : 텍스처에서만 적용(나중에 배움)

버퍼의 경우 서브리소스가 없으므로 0, RANGE도 null

리소스의 갱신
CopyResource : Upload heap -> copy -> Default heap 하는 함수 복사하는 바이트와 되는 바이트는 같아야한다.
반환형 void로 성공했는지 실패인지 구별불가

읽는 함수는 readback 타입에서만 사용 가능

