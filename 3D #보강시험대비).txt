4/30
명령 리스트의 실행

void ID3D12CommandQueue::ExecuteCo...
이 함수는 명령어 개수와 그 개수만큼의 배열을 받고 집어넣는 함수

Close()
커맨드 리스트들은 항상 닫힌 상태여야만 집어넣을 수 있음

아래 예를 통해 Reset하면 커맨드 리스트는 비워지고
그 아래 함수들로 RSSetView 등에 명령어등이 리스트에 들어감
(이 때 실행되는 것이 아님) -> 실행은 GPU가 꺼내갔을때 실행
(차례대로 돌고 때가 되어야 실행됨)
마지막에 Set 했으니 Draw 하고 집어넣기 위해서 Close로 닫고
Execute로 커맨드 리스트를 커맨드큐로 집어넣는 함수

이 후 GPU가 커맨드큐에서 명령어를 차례차례 실행시킴

각각의 커맨드들은 그리기 위한 데이터(메쉬, 월드변환행렬, 카메라 정보, 조명, 텍스처 정보 등)가 필요하다 -> 리소스에서 제공, 이 데이터들은 비디오메모리에 있어야한다. 리소스 = 비디오메모리에 있는 렌더링데이터,
이 리소스는(CreateCommittedResource, CreatePlacedResource, CreateReservedResource) 등으로 만듬
이 데이터도 그림데이터(텍스처)와 메모리덩어리 => 리소스

Cpu가 하는 일의 절차
1번과정 리소스 만들고, 필요한대로 집어넣고, 이 리소스를 사용해서 실행할 그래픽 커맨드들을 리스트로 만들어서 커맨드큐에다가 집어 넣고, 그러면 GPU는 이 명령을 실행할 때 읽어가서 사용 그러면 렌더링이 제대로 됨. 
CPU는 리소스를 바꿔가는 역할, GPU는 리소스를 꺼내쓰는 역할

2개의 CPU와 GPU가 한 리소스를 같이 쓰려하면 동기화가 필요
동기화란 쉽게 말해 줄서기.

1->2->3->4 = CPU가 데이터를 리소스에 쓰고 커맨드 리스트에 등록하면 리소스를 불러서 실행하고 다음 프레임에서 리소스를 다시 쓰는 순서

GPU가 n번째 프레임의 커맨드리스트들을 모두 실행했을 때 다음 프레임으로 넘어가는 걸 지원해주는 Fence인터페이스로 CPU와 GPU동기화할때 사용.

내부적으로 64비트짜리 데이터를 가지고 있는 com 객체

공유펜스는 - 멀티스레드때 사용
GPU공유는 - GPU가 여러개인 상황에서 GPU끼리 공유되는 상황에서 사용
동기화 오브젝트가 필요

모든 HANDLE은 UINT로 윈도우에는 많은 테이블이 있는데, HANDLE은 이 테이블에 인덱스를 의미, 테이블의 값은 실제 메모리에 주소, 이벤트들을 관리하는 테이블 역시 존재하는데, 그 테이블의 인덱스를 HANDEL이라고 하고 hEvent라고 보면 됨 왜 반환값이 HANDLE이라면 동기화 오브젝트는 따로 테이블이 있는게 아니라 엄청 큰 테이블안에 소속되어 있는 놈에 인덱스를 반환해서 그냥 HANDLE이다

커맨드큐에 signal은 원하는 값으로 바꾸는 명령을 명령큐에 추가해 라는 함수

hEvent값이 Value에 도달하면 실행된다.

GetCompleted 원하는 값이 < m_nFenceValue보다 작으면 참이되서
안에 hFenceEvent가 m_nFenceValue값이 될때 실행해
WaitForSingle은 기다려 무한정으로 저 함수가 수행될때 까지

CPU가 이프문에서 기다리면 GPU가 이 명령어를 수행하면서 값에 도달하면 이벤트를 발생하여 CPU를 깨움
이 방법으로 CPU와 GPU가 동기화한다.

===========================================================================================시험대비
