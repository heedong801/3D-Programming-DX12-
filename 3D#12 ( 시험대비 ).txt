4/17
direct 3d device = 그래픽 카드를 소프트화 시켜놓은 개념
그래픽카드가 없는 컴 있을 수 없다 = 프로그램의 출력등을 확인 못하기 때문
알파값은 불투명도를 표현
공유 자원 -> 줄서기 알고리즘 ( 동기화 )
해결책 : 자원늘리기

프레임 버퍼 1개(공유자원) 서로 읽기 쓰기 => 문제발생(Screen Tearing) 한 프레임을 복사중인데 다음 프레임이 이미 바뀌어있는 경우
스왑체인 : 순차적인 연결된 프레임버퍼들의 집합
플리핑은 전체화면에서만 동작 ( 엄청 빠름 )
프레젠테이션 : 후면 -> 전면
Com 오브젝트는 무조건 동적생성 및 소멸 해야하며, 그 방법은 기존방법이 아닌 새로운 방법으로 해야함(생성함수 별도로 존재 Create___)
Create함수는 전부 Global 함수, 소멸 역시 delete가 아닌 Release 함수 사용.

생성함수는 Device(내부적으로 클래스로 만들어짐)포인터를 리턴하는 게 아닌 Interface로 포장해서 Interface 포인터를 반환해줌
Interface가 가진 함수만 호출할 수 있으며, 내부를 들여다볼수는 없다.
Class(멤버변수, 멤버함수) /= Interface(멤버함수만 존재)
처음 Com객체는 생성시 int형 ref변수를 가지고 있음. Interface포인터를 이용해 ret변수 증가, 감소 가능
0까지 감소되면 갈비지컬렉터라는 메모리 회수 프로그램이 와서 메모리를 회수해감(객체 소멸)
모든 Com객체는 인터페이스 함수 사용가능
함수 쓰기전에 미리 변수 선언(Com의 경우 포인터, 아닌경우 Uint 등)
======================================================================================시험대비
Direct 디바이스 : 그래픽카드를 소프트화 시켜 놓은 개념
프레임버퍼 : 비디오 메모리에 있는 영역
프레임 : 렌더링이 되는 한 장의 이미지(2D) 
프레임 버퍼의 내용을 자동적으로(하드웨어적으로) 모니터로 출력

대부분 모니터는 최대 출력 해상도가 정해져있음

응용프로그램이 3000개의 이미지를 만들어도 그래픽카드가 60장밖에 못그린다면 의미가 없음
그래프나 모니터에 따라 이미 프레임은 정해져있음 웬만하면 60

수직회귀시간 > 수평회귀시간

색상표현을 위해 0~1사이 정규화된 표현을 사용한다.
색상끼리 덧칠이난 그런것은 이제 벡터의 연산으로 계산

감마란?

선형적 : 직선의 방정식 x의 변화량으로 y의 변화량을 알 수 있음 그리고 일정함
그래픽카드에서 잘 바꿨는데 모니터에서는 그만큼 바뀐게 적용되지 않음
그래서 그래픽카드에서 모니터에서 적용오차 만큼 키워서 출력해줌
감마 커렉션 : 감마를 적당히 조절해주는게 
해야하는 이유 ?
벡터의 스칼라곱등의 기본연산은 선형적
그런데 비선형적인 출력이 되면 그 연산을 했을 때 우리가 원하는 연산의 결과가 나오지 않을 수가 있다.

다렉10이상에서는 선형적인 감마커렉션을 저절로 해줌

공유자원 -> 문제발생 -> 줄서기 알고리즘( 동기화 )
			자원 늘리기

비트블릿 : 버퍼의 내용을 복사 ( 느림 )

com객체의 경우 사용은 C++같이 쓰되 생성은 무조건 동적생성및 소멸을 사용해야함

참조카운터가 0이 되면 가비지콜렉터가 수거해감

Addref, Release, QueryInterface 등 모든 com객체에 제공, 세번째는 이 객체가 어떤 인터페이스를 제공하는 가 질의

모든 Create함수는 **포인터를 사용한다. 
Com클래스의 이름은 같을 수 있으나 guid 모두 다르다. 
GUID는 인터페이스 클래스 식별자(ID)를 나타는 128비트 정수 문자열
IID 인터페이스를 구별하기 위한 GUID