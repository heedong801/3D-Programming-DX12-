4/5
XMFLOAT3A (A는 얼라인드 버전으로, 웬만하면 이거사용)
16바이트 정렬이 되도록 보장하는 구조체임
SIMD 레지스터하고 1:1 대응되게 하려면 얼라인드 버전을 쓰면 됨

XMFLOAT 4*3 쓰는 이유?
ex)월드변환 같은 경우 어차피 4번째 열은 알고 있기에 굳이 메모리를 쓸 필요 없다 하여 사용,

괄호연산자 오버로딩 -> 캐스팅(형 변환 연산자)
XMFLOAT4X4 함수에서는 캐스팅이 아닌 행과 열을 매개변수로 받으면 그에 해당하는 요소 반환하는 함수로 오버로딩
	
XMVECTOR는 x,y,z라는 변수가 없 -> 초기화는 어떻게? -> A = XMVERTORZERO() 이렇게
함수들이 다 요소별 연산
Coord 는 위치벡터로 w 0 Normal은 방향벡터로 w 1

DirectXmath에서는 평면도 벡터로 float4 짜리 써야함

Axis(월드좌표계의 축 의미) 바운딩박스와 축과 월드좌표계의 좌표는 항상 평행, 어떻게 물체가 움직이냐에 따라 바운딩박스크기 바뀜
Aligned
B운딩
B스
단점: 회전할 때마다 바운딩박스 새로 구해야함, 충돌이 정확하지 않을 수도 있음
장점: 간단하고 빠르다
2개의 벡터만 주어지면 모든 점을 알수있다(ex 최대,최소) extens는 중심과 더해져서 최대점(x,y,z가 제일큰점)등 구할수있음
Center : 바운딩 박스의 원점( 모델좌표계의 원점이 월드 좌표계의 어디에 있을 건지 )
Extent : Center에 더해져서 max, min등 나머지좌표를 구할 수 있음

OBB: 바운딩 박스의 축은 오브젝트좌표계의 축들과 평행으로, 모델이 회전하면 바운딩박스도 회전한다.
단점 : 시간이 오래걸림(알고리즘 복잡)
장점 : 정확, 회전할 때마다 바운딩 박스 구할필요 없음
회전된 2박스 충돌체크법?
점 2개를 축에 대해 투영 그러면 선분을 구할 수 있는데 각 면에 대한 선분들이 서로 겹치는 부분이 있는지 확인 x축,y축,z축으로 전부 겹쳐야
물체들이 충돌한거

박스 알고리즘의 다른 점
쿼터니언이 없으면 aabb, 있으면 obb
======================================================================================================시험대비
XMFLOAT3, XMFLOAT4를 이용하여 XMVECTOR, XMMATRIX를 클래스 멤버변수 등으로 사용 가능

XMVECTOR는 클래스가 아니고, 고로 멤버변수로 x,y,z 등이 없다
그래서 직접 초기화가 불가능하고 초기화를 해주는 함수를 제공한다.

