5/1
ID3D12DescriptorHeap

디스크립터 힙 : 디스크립터들을 표현하기위한 일종의 테이블
디스크립터를 담을 수 있는 포인터들의 배열 = 디스크립터 힙( 배열 모양의 메모리 )

힙에서 시작주소를 가져오기 위한 함수는 CPU용과 GPU용이 있음
힙 타입에 따라서 인덱스 크기가 다름 ( 디바이스 마다 다름 )
GetDes...IncrementSize함수를 통해서 크기를 알아낼 수 있음
시작주소와 인크리먼트 사이즈를 알면 다음 것을 가리킬수 있음

모든 비디오 메모리는 뷰 또는 디스크립터로 사용할 수 있다.

뷰를 만들기전에 디스크립터 힙을 먼저 만들어야 한다.
렌더타겟 뷰 타입으로 디스크립터 힙을 만들어야 함

렌더타겟이 2개가 필요하면 NumDescriptors를 2로..

디스크립터 핸들이라는 것은 어떤 메모리에 대한 주소를 의미
렌더타겟을 사용하기 위한 리소스의 디스크립터를 생성해서 그 디스크립터를 DestDescripor로 넣는다?

비디오메모리에 후면버퍼랑 똑같은 크기의 버퍼를 만들어야함
비디오메모리에 할당받기 위한 함수
CreateCommitedRe..

**ppvResource 포인트로 메모리를 나타내는 콤객체 리턴?

비디오 메모리는 기본적으로 3타입이 있는데 Default는 GPU가 사용 데이터에 접근(읽기와 쓰기 가능)한다는 얘기(대부분 이렇게 생성)
만약 둘다 사용가능 하다면 동기화에 문제가 생김

Uproad는 Cpu가 비디오메모리에 쓰는 과정으로 read는 못하는데 write는 가능, only cpu가 비디오메모리에 write하는 용도로 Gpu는 사용불가

2가지 타입의 힙을 써야함
첫째로 default타입으로 생성 cpu가 쓸수 없으니까 upload를 만듬 cpu는 비디오 메모리에 쓰고 copy함수로 dafault로 옮김
그리고 gpu는 default 를 읽어서 그림
cpu가 비디오메모리에 쓰는경우가 읽어가는 경우(ex 캡처)보다 많으니까 쓰는 경우에 해당되는 경로를 늘려서 쓰는 게 읽는 것보다 훨씬 빠름
읽을 때는 readback을 만들어놓고 default를 readback에 복사를 하고 그걸 읽어감

ex) mesh데이터의 경우 자주 쓰기 때문에 cpu가 upload에 넣고 upload를 default에 복사 그리고 upload는 이제 삭제 이렇게 씀

CPU_PAGE_PROPERTY // UNKNOWN을 쓰면됨
MEMORY_POOL // UNKNOWN을 쓰면 됨
HEAP_TYPE은 꼭 정해주기


Clear_Value란 ?
ex)뎁스버퍼를 만들면 처음에 가장 먼 뎁스값이 1로 초기화 해주는 역할을 해주여야함
비디오 메모리는 이걸 클리어해주는 것을 제공해줌(초기화 과정이 빨리 일어나도록 준비함)


Resource_states	리소스생성시 초기상태 지정
common=일반적인 상태

어떤 리소스를 읽는 중인데 그 중에 쓰기가 되면 안되므로 리소스 역시 읽기 상태를 만들어줘야함


CreateCommiittedResource()
Dimension 버퍼 or 텍스처
Alighment 위 변수를 크기에 맞게
DepthOrArraySize 얘를 사용하여 리소스 차원 표현 가능
Miplevels 버퍼이면 안써서 0, 텍스처 0일경우는 자동계산
SampletDesc 버퍼는 안씀, 텍스쳐 다중샘플링할건가?
Resource flag 리소스의 사용용도
-Render Target : 렌더타겟뷰용
-Depth Stencil : 뎁스스탠실버퍼용

렌더 타겟 뷰 (서술사) 생성

CreateDepthStencilView 전에 어떤 주소가 디스크립을 가리키게 해야하니까 GetCPUDes...를 먼저 해줘야 한다.

버퍼와 깊이 - 스텐실 버퍼 초기화
RenderTargetView
렌더 타겟은 한순간에 최대로 8개까지 만들수 있음.
첫번째 매개변수로, 디스크립터힙에서 디스크립터를 받아서 지움
두번째 매개변수로, 이 색상으로 초기화
네번째를 null로 지우면 렌더타겟 다 지움 부분적으로 지우려면 개수와 그 배열에 해당되는 것들을 배열로 해서 지움

DepthStencilView 역시 같음

파이프라인에 연결
DepthStencilDescriptor는 1개, 렌더타겟 서술자들의 배열에는 여러개가 들어 갈 수 있고, 여러개일경우 배열로 하거나, 아니면 아래 변수값을
True로 하고, 시작주소만 줄수 있음


=================================================================================================아래
렌더타겟뷰와 다른점은 렌더타겟의 후면버퍼는 스왑체인에 이미 만들어져있어서 가져다가 만들면 되는데,
뎁스스탠실뷰는 뎁스값으로만 32비트 다 쓰는게 아니라 8비트는 스텐실(0~255)(그림을 안그리는 부분)이라는 값으로 사용하여, 나머지 24비트만 뎁스값으로 만 사용할 수 있음, 뎁스스텐실버퍼에 대한 뷰
우리는 먼저 뎁스 버퍼를 만들어줘야함. 만약 만들어져 있다면 그 리소스에 대한 인터페이스 포인터를 사용해서 뎁스스탠실뷰 디스크립션으로 뷰(디스크립터)를 생성하겠다는 것

뎁스스탠실뷰는 - 뎁스버퍼로도 사용하고, 스탠실버퍼로도 사용 이 버퍼에 대한 뷰는 뎁스스탠실뷰

Creat..Resource 비디오메모리를 할달받기 위한 함수
GPU에서 가상/물리적 주소를 자동으로 관리해주는 함수

힙 프로퍼티스
-힙 타입 : 비디오 메모리를 할당을 받으면 이 사용하는 주최는 CPU or GPU 액세스(읽기쓰기)하는 건 둘중 하나임 그런데 이 비디오메모리는 기본적으로 3타입이 있는데, 디폴트는 GPU가 주로 사용할 비디오메모리(GPU는 자유 접근이 가능하나, CPU는 접근이 불가, 대부분의 리소스에 적용),이렇게 함으로써 동기화 문제 방지
두번째 업로드 타입은 CPU가 비디오메모리에다가 읽진 못하고 쓸순 있음. GPU는 접근불가
GPU가 CPU가 쓰는 데이터를 읽어가지 못하면 아무런 데이터 없이 그리는 일 발생 -> 그래서 두가지 타입의 힙을 동시에 사용 -> 전형적으로 디폴트힙을 사용해서 힙을 만듬 그러면 이 힙은 GPU가 마음대로 읽고 쓸수 있는 메모리 but CPU는 쓸수 없음 그래서 CPU는 업로드힙을 만들어서 거기다 씀. 그다음 GPU 카피명령으로 비디오메모리를 복사를 할 수 있는 함수 호출 -> 업로드 힙의 정보가 다 옮겨지면 이건 쓸모가 없어짐 -> 릴리즈. 

비디오메모리에 CPU가 쓰는건 비교적 빠르지만, 읽어가는 건 엄청 느림(그래서 프레임 동안 수행되면 안됨)
읽어가는 일은 캡처정도..
만약 읽어가는일이 필요하면 힙타입 readBack(CPU가 읽기만 가능한 놈) upload(CPU가 쓰기만 가능한 놈)

CPU가 비디오메모리를 읽을 때 디폴트 힙 -> 복사 -> readback -> 읽기

CPU 에서 비디오메모리에 옮겨줘야하는 대표적인 것(안변하는 것) - 메쉬(디폴트)

리소스를 만들려고 하면 힙 타입(디폴트, 업로드, 리드백)을 정해줘야 함

비디오메모리도 페이징시스템으로 관리( 가상메모리 처리하는데 어떤 형태로 처리할거냐 )
메모리풀 - 어떤 하드웨어냐에 따라 다르지만 잘 모르므로 언노운

힙 플래그 - 일종의 속성으로 정해줄 수 있음
그 중 DENY는 사용하지 않음의 의미로 ALLOW는 허용

클리어벨류(초기화 과정이 빨리 일어나도록 준비를 해줄 수 있음)
뎁스버퍼의 경우 매 프레임마다 1.0으로 초기화 해주는 데 클리어벨류를 사용해서 초기화 해줄수 있게 지정해줌
스텐실버퍼의 경우 0으로 ..
렌더타겟은 컬러로 초기화 해줄 때 쓰임

리소스 스테이트(리소스의 초기상태 지정)(이 리소스를 어떤 버퍼로 쓸거다 지정)
COMMON 일반적인 상태, VERTEX_AND_CONSTANT_bUFFER //정점 or 상수버퍼
복사 역시 복사소스가 될건지, 복사목표가 될건지 지정을 해줘야함
모든 리소스들은 적절한 리소스 상태를 가질수 있고, 그 상태를 되어야 그 일을 할 수 있다.

리소스 디스크립션(실제로 얼만한 메모리를 할당 받을거고, 2차원이면 가로세로의 수는? 이런걸 표현하기 위함)
리소스 디멘션 - 모든 리소스는 버퍼 or 텍스처(1차,2차,3차원)
Alignment - 모든 메모리들이 빠른 속도로 사용되기 위해서, 메모리의 시작주소들은 특정 배수가 되어야 빠르게 되도록 하드웨어가 만들어져있는데, 0넣으면 64kb로 리소스들을 얼라인해서 할당 하겠다는 의미
DepthOrArraySize - 3D 텍스처를 만들 때 사용( 리소스의 차원을 표현 )
MipLevels - 텍스처일 땐 지정, 버퍼일 때는 미지정, 0(자동계산)
FORMAT - 할당받는 메모리의 한 원소가 어떤 포맷으로 되어있나
샘플DESC - 다중샘플링 할것이지 ( 텍스처일경우 )
텍스처LAYOUT - 텍스처일경우, 2D나 3D 텍스처들을 1차원 리소스형태로 매핑을 하기 위한 방법제공 
리소스FLAG - 이 리소스는 이러이러한 사용용도로 만드는거야 ( RTV, DSV, UOA, SR )

ClearRTV/DSV - 해당 뷰를 지우는 함수
( 첫번째 인자 ) 렌더타겟의 경우 여러 개(한 순간 최대 8)이므로 어떤 놈을 지울건지 알려줘야함
( 두번째 인자 ) 초기화할 색상 4차원 벡터 Colors::Blue 다렉함수로 사용 가능
( 세번째 인자 ) 전체를 한번에 지울경우 ( 0 ) 일부만 지울경우 ( 개수 )
( 네번째 인자 ) 여러 개일 경우 배열로 집어넣음, 전체 한번 ( null )

( 첫번째 인자 ) 지울 깊이 스텐실 서술자
( 두번째 인자 ) 복수로 되어 있어서 ( 뎁스 or 스텐실 or 둘 다 )
( 세, 네번째 인자 ) 초기화 값
( 다, 여섯째 인자 ) 개수와 배열 위와 동일

생성 후 직접 파이프라인에 연결을 해줘야한다.

OMSetRenderTargets 연결 해주는 함수
( 첫번째 인자 ) 렌더타겟의 개수
( 두번째 인자 ) 렌더타겟의 배열
( 세번째 인자 ) true 이면 시작주소만 주면 됨, 아니면 배열을 주면 됨
( 네번째 인자 ) 뎁스 서술자
====================================================================================================위